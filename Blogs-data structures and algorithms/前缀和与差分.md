### 前缀和 （前缀和数组一般从下标1开始）
#### 一维前缀和
>作用：将n次查询(求[l,r]的区间和)的时间复杂度由O(n^2)降为O(n)
```S[i] = a[1] + a[2] + ... a[i]```
```a[l] + ... + a[r] = S[r] - S[l - 1]```
#### 二维前缀和
>```S[i, j] = 第i行j列格子左上部分所有元素的和```
```以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]```

### 差分
#### 一维差分
>作用：将n次查询(求将[l,r]区间上的每个数加上c后的新序列)的时间复杂度由O(n^2)降为O(n)
```
//差分模板例题
#include<iostream>
using namespace std;
const int N = 1e5 + 10;
int a[N], b[N];
int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++)
    {
        scanf("%d", &a[i]);
        b[i] = a[i] - a[i - 1];      //构建差分数组
    }
    int l, r, c;
    while (m --)
    {
        scanf("%d%d%d", &l, &r, &c);
        b[l] = b[l] + c;             //将序列中[l, r]之间的每个数都加上c
        b[r + 1] = b[r + 1] - c;
    }
    for (int i = 1; i <= n; i++)
    {
        a[i] = b[i] + a[i - 1];      //前缀和运算
        printf("%d ", a[i]);
    }
    return 0;
}
```
#### 二维差分