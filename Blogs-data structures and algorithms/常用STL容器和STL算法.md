**持续更新**
-----
### 一、共有函数
`=`：有赋值运算符以及复制构造函数。

`begin()`：返回指向开头元素的迭代器。

`end()`：返回指向末尾的下一个元素的迭代器。`end()` 不指向某个元素，但它是末尾元素的后继。

`size()`：返回容器内的元素个数。

`max_size()`：返回容器理论上能存储的最大元素个数。依容器类型和所存储变量的类型而变。

`empty()`：返回容器是否为空。

`swap()`：交换两个容器。

`clear()`：清空容器。

`==`/`!=`/`<`/`>`/`<=`/`>=`：按**字典序**比较两个容器的大小。（比较元素大小时 `map` 的每个元素相当于 `set<pair<key, value>>`，无序容器不支持 `<`/`>`/`<=`/`>=`）

### 二、迭代器 (可用auto推断迭代器类型)
迭代器本身可以看作一个数据指针，`container` 中元素的迭代器的类型一般为 `container::iterator`
定义迭代器：`vector<int>::iterator it = container.begin()`

我们在使用迭代器的其实大多数时候没有进行声明。因为C++11引入了自动类型推导（auto）的特性。
在遍历容器时，使用 auto 关键字可以让编译器根据迭代器的类型自动确定变量的类型。

#### auto

auto推断类型的原理就是根据后面的值，来自己推测前面的类型是什么。

注意：

1.用auto声明的变量必须初始化（auto是根据后面的值来推测这个变量的类型，如果后面没有值，自然会报错）

2.函数和模板参数不能被声明为auto（原因同上）

3.因为auto是一个占位符，并不是一个他自己的类型，因此不能用于类型转换或其他一些操作，如sizeof和typeid

4.定义在一个auto序列的变量必须始终推导成同一类型


auto还可以在for语句中被运用:
```cpp
int main(){
    vector<int>v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    for(auto i : v){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
```
这里for语句中的判断条件就只有 `auto i ：v`  ，格式是`for(auto i : v)`

### 三、pair
`std::pair` 是标准库中定义的一个类模板。用于将两个变量关联在一起，组成一个「对」，而且两个变量的数据类型可以是不同的。

> 类模板
    类模板（class template）本身不是一个类，而是可以根据**不同数据类型**产生**不同类**的模板。
    在使用时，编译器会根据传入的数据类型产生对应的类，再创建对应实例。


通过灵活使用 `pair`，可以轻松应对**需要将关联数据捆绑存储、处理**的场景。

>pair 与自定义 struct
    与自定义的 `struct` 相比，`pair` 不需要额外定义结构与重载运算符，因此使用起来更加简便。
    然而，自定义 `struct` 的变量命名往往更加清晰（`pair` 只能使用 `first` 与 `second` 访问包含的两个变量）。同时，如果需要将两个以上的变量进行关联，自定义 `struct` 会更加合适。

#### 1.使用
##### 初始化

可以在定义时直接完成 `pair` 的初始化。
```cpp
pair<int, double> p0(1, 2.0);
```
也可以使用先定义，后赋值的方法完成 `pair` 的初始化。
```cpp
pair<int, double> p1;
p1.first = 1;
p1.second = 2.0;
```
还可以使用 `std::make_pair` 函数。该函数接受两个变量，并返回由这两个变量组成的 `pair`。
```cpp
pair<int, double> p2 = make_pair(1, 2.0);
```
一种常用的方法是使用宏定义 `#define mp make_pair`，将有些冗长的 `make_pair` 化简为 `mp`。

在 C++11 以及之后的版本中，`make_pair` 可以配合 `auto` 使用，以避免显式声明数据类型。

```cpp
auto p3 = make_pair(1, 2.0);
```
##### 访问

通过成员函数 `first` 与 `second`，可以访问 `pair` 中包含的两个变量。

```cpp
int i = p0.first;
double d = p0.second;
```
也可以对其进行修改。
```cpp
p1.first++;
```

##### 比较

`pair` 已经预先定义了所有的比较运算符，包括 `<`、`>`、`<=`、`>=`、`==`、`!=`。当然，这需要组成 `pair` 的两个变量所属的数据类型定义了 `==` 和/或 `<` 运算符。

其中，`<`、`>`、`<=`、`>=` 四个运算符会先比较两个 `pair` 中的第一个变量，在第一个变量相等的情况下再比较第二个变量。

```cpp
if (p2 >= p3) {
  cout << "do something here" << endl;
}
```

由于 `pair` 定义了 STL 中常用的 `<` 与 `==`，使得其能够很好的与其他 STL 函数或数据结构配合。比如，`pair` 可以作为 `vector` 的数据类型。

```cpp
vector<pair<int ,int>>;
```

##### 赋值与交换

可以将 `pair` 的值赋给另一个类型一致的 `pair`。
```cpp
p0 = p1;
```
也可以使用 `swap` 函数交换 `pair` 的值。
```cpp
swap(p0, p1);
p2.swap(p3);
```
#### 2.应用举例

##### 离散化

`pair` 可以轻松实现离散化。

我们可以创建一个 `pair` 数组，将原始数据的值作为每个 `pair` 第一个变量，将原始数据的位置作为第二个变量。在排序后，将原始数据值的排名（该值排序后所在的位置）赋给该值原本所在的位置即可。

```cpp
// a为原始数据
pair<int, int> a[MAXN];
// ai为离散化后的数据
int ai[MAXN];
for (int i = 0; i < n; i++) {
  // first为原始数据的值，second为原始数据的位置
  scanf("%d", &a[i].first);
  a[i].second = i;
}
// 排序
sort(a, a + n);
for (int i = 0; i < n; i++) {
  // 将该值的排名赋给该值原本所在的位置
  ai[a[i].second] = i;
}
```


