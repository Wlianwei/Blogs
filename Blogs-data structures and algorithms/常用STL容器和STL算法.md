**持续更新**
-----
### 共有函数
`=`：有赋值运算符以及复制构造函数。

`begin()`：返回指向开头元素的迭代器。

`end()`：返回指向末尾的下一个元素的迭代器。`end()` 不指向某个元素，但它是末尾元素的后继。

`size()`：返回容器内的元素个数。

`max_size()`：返回容器理论上能存储的最大元素个数。依容器类型和所存储变量的类型而变。

`empty()`：返回容器是否为空。

`swap()`：交换两个容器。

`clear()`：清空容器。

`==`/`!=`/`<`/`>`/`<=`/`>=`：按**字典序**比较两个容器的大小。（比较元素大小时 `map` 的每个元素相当于 `set<pair<key, value>>`，无序容器不支持 `<`/`>`/`<=`/`>=`）

### 迭代器
迭代器本身可以看作一个数据指针，`container` 中元素的迭代器的类型一般为 `container::iterator`
定义迭代器：`vector<int>::iterator it = container.begin()`

我们在使用迭代器的其实大多数时候没有进行声明。因为C++11引入了自动类型推导（auto）的特性。
在遍历容器时，使用 auto 关键字可以让编译器根据迭代器的类型自动确定变量的类型。

#### auto

auto推断类型的原理就是根据后面的值，来自己推测前面的类型是什么。

注意：

1.用auto声明的变量必须初始化（auto是根据后面的值来推测这个变量的类型，如果后面没有值，自然会报错）

2.函数和模板参数不能被声明为auto（原因同上）

3.因为auto是一个占位符，并不是一个他自己的类型，因此不能用于类型转换或其他一些操作，如sizeof和typeid

4.定义在一个auto序列的变量必须始终推导成同一类型


auto还可以在for语句中被运用

 
```cpp
int main(){
    vector<int>v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    for(auto i : v){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
```
这里for语句中的判断条件就只有 `auto i ：v`  ，格式是`for(auto i : v)`
